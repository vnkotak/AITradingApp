"""
VWAP-EMA-RSI Breakout Strategy
File: vwap_ema_rsi_strategy.py

This module implements the VWAP-EMA-RSI Breakout with Dynamic ATR Targets strategy
suitable for connecting to a broker API (live) or running a backtest on historical
5-minute candles.

Features:
- Indicator engine: EMA(9), EMA(21), RSI(14), ATR(14), intraday VWAP
- Entry logic: breakout of 09:30 IST candle (with buffer), EMA/RSI/VWAP confirmations
- Exit logic: TP/SL (based on ATR multipliers) and dynamic early exits (EMA cross, RSI flip, VWAP cross)
- Backtest mode (runs on historical DataFrame) and Live mode (stubs for streaming updates)
- OCO order handling stub (user must plug broker API methods)

Usage examples:
- Backtest: call run_backtest(candles_df, params)
- Live mode: instantiate LiveAlgo(params) and call on_new_candle(candle_dict)

Assumptions:
- Input candles are 5-minute bars in UTC timestamps with columns: ['ts','open','high','low','close','volume']
- 'ts' should be pandas datetime64[ns, UTC] or convertible via pd.to_datetime(..., utc=True)

Author: Generated by ChatGPT (GPT-5 Thinking mini) for user
"""

from dataclasses import dataclass, asdict
from typing import Optional, Dict, Any, List, Tuple
import pandas as pd
import numpy as np
from datetime import datetime, time, timedelta, timezone

# -------------------------
# Parameters / Config
# -------------------------
@dataclass
class StrategyParams:
    ema_short: int = 9
    ema_long: int = 21
    rsi_period: int = 14
    atr_period: int = 14
    breakout_buffer_pct: float = 0.001   # 0.1%
    sl_atr_mul: float = 1.0
    tp_atr_mul: float = 2.0
    rsi_buy_th: float = 55.0
    rsi_sell_th: float = 45.0
    rsi_exit_th: float = 50.0
    session_start_ist: time = time(hour=9, minute=30)
    session_cutoff_ist: time = time(hour=15, minute=20)
    timezone_utc = timezone.utc

# -------------------------
# Indicator helpers
# -------------------------

def compute_indicators(df: pd.DataFrame, params: StrategyParams) -> pd.DataFrame:
    """Compute EMA, RSI, ATR, and intraday VWAP for provided candles.

    Expects df sorted by timestamp ascending and 'ts' as UTC tz-aware.
    Returns a copy of df with new columns: EMA9, EMA21, RSI14, ATR14, VWAP
    """
    df = df.copy()
    df['close'] = df['close'].astype(float)
    # EMAs
    df[f'EMA{params.ema_short}'] = df['close'].ewm(span=params.ema_short, adjust=False).mean()
    df[f'EMA{params.ema_long}'] = df['close'].ewm(span=params.ema_long, adjust=False).mean()

    # RSI (EMA smoothing)
    delta = df['close'].diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.ewm(alpha=1/params.rsi_period, adjust=False).mean()
    ma_down = down.ewm(alpha=1/params.rsi_period, adjust=False).mean()
    rs = ma_up / ma_down
    df[f'RSI{params.rsi_period}'] = 100 - (100 / (1 + rs))

    # ATR (True Range smoothed by EMA)
    tr1 = df['high'] - df['low']
    tr2 = (df['high'] - df['close'].shift()).abs()
    tr3 = (df['low'] - df['close'].shift()).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    df[f'ATR{params.atr_period}'] = tr.ewm(alpha=1/params.atr_period, adjust=False).mean()

    # Intraday VWAP: must reset at session start. We'll compute VWAP aggregated from session start in the file
    df['typ_price'] = (df['high'] + df['low'] + df['close']) / 3.0
    df['vp'] = df['typ_price'] * df['volume']

    # Create a session key (date in IST) to reset VWAP per session
    ist_offset = timedelta(hours=5, minutes=30)
    df['ts_ist'] = df['ts'] + ist_offset
    df['session_date_ist'] = df['ts_ist'].dt.date

    df['cum_vol'] = df.groupby('session_date_ist')['volume'].cumsum()
    df['cum_vp'] = df.groupby('session_date_ist')['vp'].cumsum()
    df['VWAP'] = df['cum_vp'] / df['cum_vol'].replace({0: np.nan}).ffill()

    # cleanup helper columns
    df.drop(columns=['typ_price','vp','cum_vol','cum_vp','ts_ist','session_date_ist'], inplace=True)
    return df

# -------------------------
# Signal & Execution logic
# -------------------------

def get_930_reference(df: pd.DataFrame, params: StrategyParams) -> Optional[int]:
    """Return index of the 09:30 IST candle for each session in df.

    For a given session (df should be for one UTC date), find first candle at or after 04:00 UTC
    which corresponds to 09:30 IST. Returns the integer index in df or None.
    """
    # compute target UTC time for each unique date in df['ts']
    if df.empty:
        return None
    # Find the first row where ts (UTC) converted to IST has time >= 09:30
    ist_offset = timedelta(hours=5, minutes=30)
    ts_ist = df['ts'] + ist_offset
    mask = ts_ist.dt.time >= params.session_start_ist
    candidates = df[mask]
    if candidates.empty:
        return None
    # pick the first candidate for that session
    return candidates.index[0]


def build_trade_from_breakout(df: pd.DataFrame, entry_idx: int, params: StrategyParams, breakout_buf: float,
                              bias: str, i: int) -> Optional[Dict[str, Any]]:
    """Create trade dict when breakout occurs at row i (i > entry_idx)."""
    high_930 = float(df.loc[entry_idx, 'high'])
    low_930 = float(df.loc[entry_idx, 'low'])
    buy_trigger = high_930 * (1 + breakout_buf)
    sell_trigger = low_930 * (1 - breakout_buf)

    row = df.loc[i]
    atr_now = float(row.get(f'ATR{params.atr_period}', np.nan))
    if math.isnan(atr_now):
        atr_now = float(df.loc[entry_idx].get(f'ATR{params.atr_period}', 0.0))

    if row['high'] >= buy_trigger and bias in ['buy','neutral']:
        entry_price = buy_trigger
        sl = low_930 - params.sl_atr_mul * atr_now
        tp = entry_price + params.tp_atr_mul * atr_now
        return {'side':'buy','entry_time':row['ts'],'entry_price':entry_price,'sl':sl,'tp':tp,'atr':atr_now}
    if row['low'] <= sell_trigger and bias in ['sell','neutral']:
        entry_price = sell_trigger
        sl = high_930 + params.sl_atr_mul * atr_now
        tp = entry_price - params.tp_atr_mul * atr_now
        return {'side':'sell','entry_time':row['ts'],'entry_price':entry_price,'sl':sl,'tp':tp,'atr':atr_now}
    return None

import math

def simulate_session(df: pd.DataFrame, params: StrategyParams, breakout_buf: float) -> Dict[str, Any]:
    """Simulate a single session (df belongs to one UTC date) and return trade result or None.

    Rules implemented exactly as the strategy spec.
    """
    result = {'trade': None}
    if df.empty:
        return result
    entry_idx = get_930_reference(df, params)
    if entry_idx is None:
        return result

    # indicator values at entry
    entry_row = df.loc[entry_idx]
    ema9 = float(entry_row.get(f'EMA{params.ema_short}', np.nan))
    ema21 = float(entry_row.get(f'EMA{params.ema_long}', np.nan))
    rsi = float(entry_row.get(f'RSI{params.rsi_period}', np.nan))
    vwap = float(entry_row.get('VWAP', np.nan))

    # bias determination
    if (ema9 > ema21) and (rsi > params.rsi_buy_th) and (entry_row['close'] > vwap):
        bias = 'buy'
    elif (ema9 < ema21) and (rsi < params.rsi_sell_th) and (entry_row['close'] < vwap):
        bias = 'sell'
    else:
        bias = 'neutral'

    # scan forward for breakout and manage trade
    trade = None
    for i in range(entry_idx+1, len(df)):
        row = df.loc[i]
        # if no trade, check breakout
        if trade is None:
            trade = build_trade_from_breakout(df, entry_idx, params, breakout_buf, bias, i)
            continue
        # if trade exists, check exit conditions
        if trade['side']=='buy':
            # SL / TP
            if row['low'] <= trade['sl']:
                trade['exit_price'] = trade['sl']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'SL'; break
            if row['high'] >= trade['tp']:
                trade['exit_price'] = trade['tp']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'TP'; break
            # dynamic exits
            ema9_now = float(row.get(f'EMA{params.ema_short}', np.nan))
            ema21_now = float(row.get(f'EMA{params.ema_long}', np.nan))
            rsi_now = float(row.get(f'RSI{params.rsi_period}', np.nan))
            vwap_now = float(row.get('VWAP', np.nan))
            if (ema9_now < ema21_now):
                trade['exit_price'] = row['close']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'EMA Cross'; break
            if (rsi_now < params.rsi_exit_th):
                trade['exit_price'] = row['close']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'RSI Exit'; break
            if (row['close'] < vwap_now):
                trade['exit_price'] = row['close']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'Below VWAP'; break
            # trailing SL (move to max(prev_sl, entry - ATR) -- conservative)
            atr_now = float(row.get(f'ATR{params.atr_period}', trade['atr']))
            trade['sl'] = max(trade['sl'], trade['entry_price'] - atr_now)
        else:  # sell
            if row['high'] >= trade['sl']:
                trade['exit_price'] = trade['sl']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'SL'; break
            if row['low'] <= trade['tp']:
                trade['exit_price'] = trade['tp']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'TP'; break
            ema9_now = float(row.get(f'EMA{params.ema_short}', np.nan))
            ema21_now = float(row.get(f'EMA{params.ema_long}', np.nan))
            rsi_now = float(row.get(f'RSI{params.rsi_period}', np.nan))
            vwap_now = float(row.get('VWAP', np.nan))
            if (ema9_now > ema21_now):
                trade['exit_price'] = row['close']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'EMA Cross'; break
            if (rsi_now > params.rsi_exit_th):
                trade['exit_price'] = row['close']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'RSI Exit'; break
            if (row['close'] > vwap_now):
                trade['exit_price'] = row['close']; trade['exit_time'] = row['ts']; trade['exit_reason'] = 'Above VWAP'; break
            atr_now = float(row.get(f'ATR{params.atr_period}', trade['atr']))
            trade['sl'] = min(trade['sl'], trade['entry_price'] + atr_now)

    # close open trade at EOD if not closed
    if trade is not None and 'exit_price' not in trade:
        trade['exit_price'] = df.iloc[-1]['close']
        trade['exit_time'] = df.iloc[-1]['ts']
        trade['exit_reason'] = 'EOD'

    result['trade'] = trade
    result['bias'] = bias
    return result

# -------------------------
# Backtest harness
# -------------------------

def run_backtest(candles: pd.DataFrame, params: StrategyParams, buffers: List[float]=[0.0005,0.001,0.0015]) -> pd.DataFrame:
    """Run parameter sweep backtest across multiple sessions (dates) and return results DataFrame.

    candles: full dataset (UTC timestamps), must include multiple session days.
    params: strategy default params
    buffers: list of breakout buffer percentages to try
    """
    candles = candles.copy()
    if 'ts' not in candles.columns:
        raise ValueError("candles DataFrame must contain 'ts' column")
    candles['ts'] = pd.to_datetime(candles['ts'], utc=True)
    # compute indicators once
    candles_ind = compute_indicators(candles, params)

    # group by UTC date (session)
    candles_ind['date_utc'] = candles_ind['ts'].dt.date
    dates = sorted(candles_ind['date_utc'].unique())

    rows = []
    for d in dates:
        session_df = candles_ind[candles_ind['date_utc']==d].reset_index(drop=True)
        if session_df.empty:
            continue
        for buf in buffers:
            res = simulate_session(session_df, params, buf)
            trade = res.get('trade')
            if trade is None:
                rows.append({'date': d, 'buffer': buf, 'side': None, 'pnl_pct': np.nan, 'exit_reason': None})
            else:
                pnl_points = (trade['exit_price'] - trade['entry_price']) if trade['side']=='buy' else (trade['entry_price'] - trade['exit_price'])
                pnl_pct = pnl_points / trade['entry_price'] * 100.0
                rows.append({'date': d, 'buffer': buf, 'side': trade['side'], 'entry_time': trade['entry_time'],
                             'exit_time': trade['exit_time'], 'exit_reason': trade.get('exit_reason'),
                             'pnl_points': pnl_points, 'pnl_pct': pnl_pct, 'sl': trade.get('sl'), 'tp': trade.get('tp')})
    return pd.DataFrame(rows)

# -------------------------
# Live Algo class (stubs for integration)
# -------------------------
class LiveAlgo:
    """Lightweight class to integrate into a streaming environment.

    Usage:
        algo = LiveAlgo(params)
        on each new 5-min candle call: algo.on_new_candle(candle_dict)
    """
    def __init__(self, params: StrategyParams):
        self.params = params
        self.buffer = params.breakout_buffer_pct
        self._session_candles = []  # store current session candles
        self._current_trade = None

    def on_new_candle(self, candle: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Process a new 5-min candle (dict with ts, open, high, low, close, volume).

        Returns executed trade dict when entry or exit happens. Otherwise None.
        """
        # append
        self._session_candles.append(candle)
        df = pd.DataFrame(self._session_candles)
        df['ts'] = pd.to_datetime(df['ts'], utc=True)
        df = compute_indicators(df, self.params)

        # If session start, detect 9:30 and set reference
        entry_idx = get_930_reference(df, self.params)
        if entry_idx is None:
            return None

        # If no trade, check breakout in the latest candle
        latest_idx = df.index[-1]
        if self._current_trade is None and latest_idx > entry_idx:
            # determine bias using entry candle
            entry_row = df.loc[entry_idx]
            ema9 = float(entry_row.get(f'EMA{self.params.ema_short}', np.nan))
            ema21 = float(entry_row.get(f'EMA{self.params.ema_long}', np.nan))
            rsi = float(entry_row.get(f'RSI{self.params.rsi_period}', np.nan))
            vwap = float(entry_row.get('VWAP', np.nan))
            if (ema9 > ema21) and (rsi > self.params.rsi_buy_th) and (entry_row['close'] > vwap):
                bias = 'buy'
            elif (ema9 < ema21) and (rsi < self.params.rsi_sell_th) and (entry_row['close'] < vwap):
                bias = 'sell'
            else:
                bias = 'neutral'

            trade = build_trade_from_breakout(df, entry_idx, self.params, self.buffer, bias, latest_idx)
            if trade is not None:
                # place order via broker (user implements place_order)
                self._current_trade = trade
                self._current_trade['status'] = 'open'
                # user should call place_order(trade) -> returns order id
                return {'action':'enter','trade':trade}

        # If trade active, evaluate exits
        if self._current_trade is not None:
            # find exit conditions based on the latest candle
            row = df.iloc[-1]
            if self._current_trade['side']=='buy':
                if row['low'] <= self._current_trade['sl']:
                    self._current_trade['exit_price'] = self._current_trade['sl']
                    self._current_trade['exit_time'] = row['ts']
                    self._current_trade['exit_reason'] = 'SL'
                elif row['high'] >= self._current_trade['tp']:
                    self._current_trade['exit_price'] = self._current_trade['tp']
                    self._current_trade['exit_time'] = row['ts']
                    self._current_trade['exit_reason'] = 'TP'
                else:
                    ema9_now = float(row.get(f'EMA{self.params.ema_short}', np.nan))
                    ema21_now = float(row.get(f'EMA{self.params.ema_long}', np.nan))
                    rsi_now = float(row.get(f'RSI{self.params.rsi_period}', np.nan))
                    vwap_now = float(row.get('VWAP', np.nan))
                    if ema9_now < ema21_now or rsi_now < self.params.rsi_exit_th or row['close'] < vwap_now:
                        self._current_trade['exit_price'] = row['close']
                        self._current_trade['exit_time'] = row['ts']
                        self._current_trade['exit_reason'] = 'Dynamic Exit'
            else:
                if row['high'] >= self._current_trade['sl']:
                    self._current_trade['exit_price'] = self._current_trade['sl']
                    self._current_trade['exit_time'] = row['ts']
                    self._current_trade['exit_reason'] = 'SL'
                elif row['low'] <= self._current_trade['tp']:
                    self._current_trade['exit_price'] = self._current_trade['tp']
                    self._current_trade['exit_time'] = row['ts']
                    self._current_trade['exit_reason'] = 'TP'
                else:
                    ema9_now = float(row.get(f'EMA{self.params.ema_short}', np.nan))
                    ema21_now = float(row.get(f'EMA{self.params.ema_long}', np.nan))
                    rsi_now = float(row.get(f'RSI{self.params.rsi_period}', np.nan))
                    vwap_now = float(row.get('VWAP', np.nan))
                    if ema9_now > ema21_now or rsi_now > self.params.rsi_exit_th or row['close'] > vwap_now:
                        self._current_trade['exit_price'] = row['close']
                        self._current_trade['exit_time'] = row['ts']
                        self._current_trade['exit_reason'] = 'Dynamic Exit'

            if 'exit_price' in self._current_trade:
                # mark closed and return exit
                closed = self._current_trade.copy()
                closed['status'] = 'closed'
                self._current_trade = None
                return {'action':'exit','trade':closed}

        return None

# -------------------------
# Broker integration placeholders
# -------------------------

def place_order_stub(trade: Dict[str, Any]) -> Dict[str, Any]:
    """Replace with actual broker API order placement.

    Return a dict with order_id and execution details.
    """
    # Example stub
    return {'order_id': 'SIM123', 'filled_price': trade['entry_price'], 'filled_qty': 1}

# -------------------------
# If run as script, demonstration
# -------------------------
if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Run VWAP-EMA-RSI strategy backtest/demo')
    parser.add_argument('--csv', type=str, required=False, help='Path to 5-min candles CSV (ts,open,high,low,close,volume)')
    parser.add_argument('--demo', action='store_true')
    args = parser.parse_args()

    params = StrategyParams()
    if args.csv:
        data = pd.read_csv(args.csv)
        data['ts'] = pd.to_datetime(data['ts'], utc=True)
        res = run_backtest(data, params)
        print(res.head())
    elif args.demo:
        print('Demo mode: instantiate LiveAlgo and feed a few rows (not implemented in CLI)')
    else:
        print('No CSV provided. Module loaded for import.')
